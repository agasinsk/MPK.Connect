using System;
using System.Collections.Generic;
using System.Linq;
using MPK.Connect.Service.Business.HarmonySearch.Constants;
using MPK.Connect.Service.Business.HarmonySearch.Generator;
using MPK.Connect.Service.Business.HarmonySearch.Helpers;
using MPK.Connect.Service.Business.HarmonySearch.ParameterProviders;

namespace MPK.Connect.Service.Business.HarmonySearch.Core
{
    /// <summary>
    /// Harmony search with ant colony optimization incorporated
    /// </summary>
    /// <typeparam name="T">Type of entities</typeparam>
    public class AntColonyHarmonySearcher<T> : HarmonySearcher<T>
    {
        private readonly IAntColonyOptimizer<T> _antColonyOptimizer;

        private readonly int _maxImprovisationCountWithTheSameBestValue;
        private double _bestHarmonyObjectiveValue;
        private int _improvisationCountWithTheSameBestValue;
        public override HarmonySearchType Type => HarmonySearchType.AntColony;

        public AntColonyHarmonySearcher(IHarmonyGenerator<T> harmonyGenerator, IParameterProvider parameterProvider, IAntColonyOptimizer<T> antColonyOptimizer, int harmonyMemorySize = HarmonySearchConstants.DefaultHarmonyMemorySize, long maxImprovisationCount = HarmonySearchConstants.DefaultMaxImprovisationCount) : base(harmonyGenerator, parameterProvider, harmonyMemorySize, maxImprovisationCount)
        {
            _antColonyOptimizer = antColonyOptimizer ?? throw new ArgumentNullException(nameof(antColonyOptimizer));

            _bestHarmonyObjectiveValue = double.PositiveInfinity;
            _maxImprovisationCountWithTheSameBestValue = (int)(maxImprovisationCount / 10);
        }

        public override Harmony<T> SearchForHarmony()
        {
            InitializeHarmonyMemory();

            while (SearchingShouldContinue())
            {
                var worstHarmony = HarmonyMemory.WorstHarmony;

                // Get parameters
                var harmonyMemoryConsiderationRatio = ParameterProvider.HarmonyMemoryConsiderationRatio;
                var pitchAdjustmentRatio = ParameterProvider.PitchAdjustmentRatio;

                // Improvise harmony with the new parameters
                var improvisedHarmony = HarmonyGenerator.ImproviseHarmony(harmonyMemoryConsiderationRatio, pitchAdjustmentRatio);

                if (improvisedHarmony.IsBetterThan(worstHarmony) && !HarmonyMemory.Contains(improvisedHarmony))
                {
                    HarmonyMemory.SwapWithWorstHarmony(improvisedHarmony);
                }

                // Update global pheromone using the best harmony
                _antColonyOptimizer.UpdateGlobalPheromone(HarmonyMemory.BestHarmony);

                // Get ant solutions
                var antSolutions = _antColonyOptimizer.GetAntColontSolutions(HarmonyMemory.MaxCapacity);

                // Merge ant solutions with improvised ones
                MergeHarmonyMemoryWithAntSolutions(antSolutions);

                // Save best solution
                SaveBestHarmony(HarmonyMemory.BestHarmony);
                ImprovisationCount++;
            }

            return HarmonyMemory.BestHarmony;
        }

        /// <summary>
        /// Checks if algorithm should continue working
        /// </summary>
        protected override bool SearchingShouldContinue()
        {
            return ImprovisationCount < MaxImprovisationCount && _improvisationCountWithTheSameBestValue < _maxImprovisationCountWithTheSameBestValue;
        }

        /// <summary>
        /// Merges solutions from Harmony Memory and generated by ant colony optimization
        /// </summary>
        /// <param name="antColonySolutions">Ant colony solutions</param>
        private void MergeHarmonyMemoryWithAntSolutions(IEnumerable<Harmony<T>> antColonySolutions)
        {
            var allHarmonies = HarmonyMemory.GetAll()
                .Concat(antColonySolutions)
                .OrderBy(h => h.ObjectiveValue)
                .ToList();

            HarmonyMemory.Clear();

            HarmonyMemory.AddRange(allHarmonies);
        }

        /// <summary>
        /// Saves the objective value of the best harmony
        /// </summary>
        /// <param name="bestHarmony">Best harmony in current iteration</param>
        private void SaveBestHarmony(Harmony<T> bestHarmony)
        {
            if (Math.Abs(_bestHarmonyObjectiveValue - bestHarmony.ObjectiveValue) < 0.001)
            {
                _improvisationCountWithTheSameBestValue++;
            }

            _bestHarmonyObjectiveValue = bestHarmony.ObjectiveValue;
        }
    }
}