using MPK.Connect.Service.Business.HarmonySearch.Constants;
using MPK.Connect.Service.Business.HarmonySearch.Generator;
using MPK.Connect.Service.Business.HarmonySearch.Helpers;
using MPK.Connect.Service.Business.HarmonySearch.ParameterProviders;
using System;
using System.Collections.Generic;
using System.Linq;

namespace MPK.Connect.Service.Business.HarmonySearch.Core
{
    /// <summary>
    /// Harmony search with ant colony optimization incorporated
    /// </summary>
    /// <typeparam name="T">Type of entities</typeparam>
    public class AntColonyHarmonySearcher<T> : HarmonySearcher<T>
    {
        private readonly IAntColonyOptimizer<T> _antColonyOptimizer;

        public override HarmonySearchType Type => HarmonySearchType.AntColony;

        /// <summary>
        /// Initializes a new instance of the <see cref="AntColonyHarmonySearcher{T}"/> class.
        /// </summary>
        /// <param name="harmonyGenerator">The harmony generator.</param>
        /// <param name="parameterProvider">The parameter provider.</param>
        /// <param name="antColonyOptimizer">The ant colony optimizer.</param>
        /// <param name="harmonyMemorySize">Size of the harmony memory.</param>
        /// <param name="maxImprovisationCount">The maximum improvisation count.</param>
        /// <exception cref="ArgumentNullException">antColonyOptimizer</exception>
        public AntColonyHarmonySearcher(IHarmonyGenerator<T> harmonyGenerator, IParameterProvider parameterProvider,
            IAntColonyOptimizer<T> antColonyOptimizer,
            int harmonyMemorySize = HarmonySearchConstants.DefaultHarmonyMemorySize,
            long maxImprovisationCount = HarmonySearchConstants.DefaultMaxImprovisationCount) : base(harmonyGenerator,
            parameterProvider, harmonyMemorySize, maxImprovisationCount)
        {
            _antColonyOptimizer = antColonyOptimizer ?? throw new ArgumentNullException(nameof(antColonyOptimizer));

            MaxImprovisationCountWithTheSameBestValue = (int)(maxImprovisationCount / 20);
        }

        /// <inheritdoc/>
        /// <summary>
        /// Resets this instance.
        /// </summary>
        public override void Reset()
        {
            base.Reset();

            _antColonyOptimizer.Reset();
        }

        /// <summary>
        /// Looks for optimal solution of a function
        /// </summary>
        /// <returns></returns>
        /// <inheritdoc/>
        public override Harmony<T> SearchForHarmony()
        {
            InitializeHarmonyMemory();

            ImprovisationCount = 0;
            ImprovisationCountWithTheSameBestValue = 0;

            while (SearchingShouldContinue())
            {
                var worstHarmony = HarmonyMemory.WorstHarmony;

                // Get parameters
                var harmonyMemoryConsiderationRatio = ParameterProvider.HarmonyMemoryConsiderationRatio;
                var pitchAdjustmentRatio = ParameterProvider.PitchAdjustmentRatio;

                // Improvise harmony with the new parameters
                var improvisedHarmony = HarmonyGenerator.ImproviseHarmony(harmonyMemoryConsiderationRatio, pitchAdjustmentRatio);

                if (improvisedHarmony.IsBetterThan(worstHarmony) && !HarmonyMemory.Contains(improvisedHarmony))
                {
                    HarmonyMemory.SwapWithWorstHarmony(improvisedHarmony);
                }

                // Update global pheromone using the best harmony
                _antColonyOptimizer.UpdateGlobalPheromone(HarmonyMemory.BestHarmony);

                // Get ant solutions
                var antSolutions = _antColonyOptimizer.GetAntColonySolutions(HarmonyMemory.MaxCapacity);

                // Merge ant solutions with improvised ones
                MergeHarmonyMemoryWithAntSolutions(antSolutions);

                // Save best solution
                SaveBestHarmony(HarmonyMemory.BestHarmony);

                ImprovisationCount++;
            }

            return HarmonyMemory.BestHarmony;
        }

        /// <summary>
        /// Merges solutions from Harmony Memory and generated by Ant Colony optimization
        /// </summary>
        /// <param name="antColonySolutions">Ant colony solutions</param>
        private void MergeHarmonyMemoryWithAntSolutions(IEnumerable<Harmony<T>> antColonySolutions)
        {
            var allHarmonies = HarmonyMemory.GetAll()
                .Concat(antColonySolutions)
                .OrderBy(h => h.ObjectiveValue)
                .ToList();

            HarmonyMemory.Clear();

            HarmonyMemory.AddRange(allHarmonies);
        }
    }
}